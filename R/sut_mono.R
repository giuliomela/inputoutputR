#' Supply and Use model
#'
#' This function builds and resolve a supply and use model to assess the impact generated by the creation of a new product/sector in
#' the Italian economy. Supply and Use tables are from the OECD. The function loads an user-defined input spreadsheet containing
#' information on inputs used by the new sectors, their provenance, people working in the new sector, etc. This file should respect a given
#' format. The function returns the overall impact on output, intermediate and final imports, value added, gdp and employment, as well as
#' multipliers' matrices (output, value added, jobs created).
#'
#' @param type A string that can assume two values: either `type1` or `type2`. In case `type1` is specified, final consumption is trated
#'     as an exogenous variable (direct and indirect effect only). If `type2` is specified, final consumption is trated as endgenous and total impact include direct,
#'     indirect and induced effects.
#' @param sector The ISTAT code of the sector to which the new product/sector belongs in the real world and from which the latter must
#'     be extrapolated.
#' @param new_sector_name The name of the new sector/product to be created
#' @param transport_distribution_services A vector of ISTAT product/service codes denoting transportation and distribution services
#'     (needed to convert inputs, expressed at purchasers' prices into base prices)
#' @param prices A string denoting whether the analysis must be carried out at base (`pb`) or pruchasers' (`pa`) prices. The former are
#'     used to assess the impact of the new sector in full operation, while the latter to assess the impact of the building phase.
#' @param sector_to_join,product_to_join Sector and product ISTAT codes of the sector/product to be grouped with sector `V96` and product
#'     `R26` respectively to "make" room for the new sector/products into the matrices.
#' @param destination_sector,destination_product Sector and product ISTAT codes of the sector/product to which `sector_to_join` and
#'     `product_to_join` must be added to.
#' @return A list with all simulation results: overall impacts on output, value added, employment, imports and multipliers.
#' @export
#' @examples
#' # sut_mono()
sut_mono <- function(
  type = "type1",
  sector = "V27", # settore di appartenenza dell'oggetto della valutazizone (es. apparecchiature elettriche)
  new_sector_name = "FAAM",
  transport_distribution_services = c("RD", "R45", "R46", "R47", "R49", "R50", "R51"),
  prices = "pb",
  sector_to_join = "VT",
  product_to_join = "RT",
  destination_sector = "V96",
  destination_product = "R96"
  ){

  path <- file.choose()

  # rearranging tables and vectors to make room for the new sector

  tables_rearranged <- purrr::map(
    c("sut", "employment", "emissions"),
    \(x) rearrange_tables(
      sector_to_join = {{sector_to_join}},
      product_to_join = {{product_to_join}},
      destination_sector = {{destination_sector}},
      destination_product = {{destination_product}},
      type = x
    )
  ) |> purrr::set_names(c("sut", "employment", "emissions"))

  #return(tables_rearranged)

  # loading input data (exogenous demand variation)

  input <- preparing_input(
    input_path = path,
    sector = {{sector}},
    transport_distribution_services = {{transport_distribution_services}},
    new_sector_name = {{new_sector_name}}
  )

  ### Adding the new sector/product to the rearranged tables

 table_sim_names <- setdiff(
   names(tables_rearranged$sut),
   c("margins", "final_taxes", "use_pa", "use_t_pa")
 )


 tables_sim <- purrr::map(
   table_sim_names,
   \(x){

     if (!stringr::str_detect(x, "final_use")){

     out <- cbind(tables_rearranged[["sut"]][[x]], input[[x]])

     colnames(out)[ncol(out)] <- new_sector_name

     new_sector_output <- input$va[["P1"]]

     additional_row <- dplyr::case_when(
       x == "use_pb" ~ c(input[["output_to_sectors"]], 0),
       x == "use_t_pb" ~ rep(0, ncol(out)),
       x == "supply" ~ c(rep(0, ncol(out) - 1), new_sector_output),
       x == "taxes" ~ rep(0, ncol(out))
     )

     if(x != "va"){

       names(additional_row) <- c(rownames(tables_rearranged[["sut"]][[x]]), new_sector_name)

       out <- rbind(out, additional_row)

       rownames(out) <- c(rownames(tables_rearranged[["sut"]][[x]]), new_sector_name)

     }

     if(x != "supply"){

     out[, sector] <- out[, sector] - out[, new_sector_name] # substracting new sector from the one it belogns in the real world

     }

     out

     } else {

     out <- tables_rearranged[["sut"]][[x]]

     if(stringr::str_detect(x, "_t_")){

      additional_row <- input[["final_use_t_pa"]][nrow(input[["final_use_t_pa"]]), ]

     } else {

      additional_row <- input[["final_use_pa"]][nrow(input[["final_use_pa"]]), ]

     }

     out <- rbind(out, additional_row)

     rownames(out)[nrow(out)] <- new_sector_name

     out

   }
}
 ) |> purrr::set_names(table_sim_names)


 # rearranging employment vector

 employed <- exogenous_vectors(
   input_vector = tables_rearranged$employment,
   new_sector_name = {{new_sector_name}},
   sector = {{sector}},
   input_value = input$employed
 )

 tables_sim[["employed"]] <- employed

 # rearranging emissions vectors

 emissions <- rearrange_tables(
   sector_to_join = {{sector_to_join}},
   product_to_join = {{product_to_join}},
   destination_sector = {{destination_sector}},
   destination_product = {{destination_product}},
   type = "emissions"
 )

 emissions_l <-  purrr::map(
   names(emissions),
   \(x) {

     out_l <- emissions[[x]]

     purrr::map(
       names(out_l),
       \(y) {

         input_value <- input[["emissions"]][[x]][[y]]

         out_v <- exogenous_vectors(
           input_vector = tables_rearranged$employment,
           new_sector_name = {{new_sector_name}},
           sector = {{sector}},
           input_value = input_value
           )

       }
     ) |> purrr::set_names(names(out_l))
   }
 ) |> purrr::set_names(names(emissions))


 tables_sim[["emissions"]] <- emissions_l


 ### Defining working matrices to run the simulation

 sectors <- colnames(tables_sim$use_pb)

 products <- rownames(tables_sim$use_pb)

 # make matrix

 make <- t(tables_sim$supply)

 # B matrices

 B_matrix <- tables_sim$use_pb %*% diag(tables_sim$va["P1", ]^-1)

 colnames(B_matrix) <- colnames(tables_sim$use_pb)

# T matrix (element by element ratio between use and use_import matrices)

 T_matrix <- tables_sim$use_t_pb / tables_sim$use_pb

 T_matrix[is.na(T_matrix)] <- 0

 T_matrix_final <- tables_sim$final_use_t_pb / tables_sim$final_use_pb

 T_matrix_final[is.na(T_matrix_final)] <- 0

 # Final domestic demand (final demand minus imported items satisfying final demand)

 final_demand_domestic <- input$final_use_pa

 # D matrix (market shares)

  D_matrix <- make %*% diag(colSums(make)^-1)

  colnames(D_matrix) <- colnames(make)

  # L inverse matrix

  I <- diag(rep(1, 63*2))

  R_matrix <- B_matrix * (1 - T_matrix) # matrice data da 1 - coefficienti di importazione. Moltiplicazione elemento per elemento

  R_matrix_final <- 1 - T_matrix_final

  zero_matrix <- diag(rep(0, 63))

  L_matrix <- solve(I - cbind(
    rbind(zero_matrix, D_matrix),
    rbind(R_matrix, zero_matrix)
  )
  )

  rownames(L_matrix) <- c(
    rownames(R_matrix),
    rownames(D_matrix)
  )

  colnames(L_matrix) <- c(
    colnames(D_matrix),
    colnames(R_matrix)
  )

  ### Computing the new output and the other variables of interest

  # computing total taxes (to be added to the output value of the new sector)

  total_tax <- input$taxes |> sum()

  final_demand_domestic[new_sector_name, "P51G"] <- final_demand_domestic[new_sector_name, "P51G"] + total_tax

  # Total output

  output <- L_matrix %*% rbind(final_demand_domestic * R_matrix_final,
                     matrix(rep(0, ncol(final_demand_domestic)*nrow(final_demand_domestic)), ncol = ncol(final_demand_domestic)))

  # computing value added changes

  va_ratio <- tables_sim$va["B1G", ] / tables_sim$va["P1", ]

  va <- rowSums(output[sectors, ]) * va_ratio

  # computing intermediate imports

  intermediate_imports <- (B_matrix * T_matrix) %*% rowSums(output[products, ])

  # Computing indirect taxes

  taxes_share <- colSums(tables_sim$taxes) / tables_sim$va["P1", ]

  indirect_taxes <- rowSums(output)[sectors] * t(taxes_share)

  # Employment

  employed_over_output <- tables_sim$employed / tables_sim$va["P1", ]

  employment <- rowSums(output)[sectors] * employed_over_output

  # Emissions

  emissions <- purrr::map(
    names(tables_sim$emissions),
    \(x){

      emi <- tables_sim$emissions[[x]]

      purrr::map(
        names(emi),
        \(y) {

          ratio <- emi[[y]] / tables_sim$va["P1", ]

          out <- rowSums(output)[sectors] * ratio

          out

        }
      ) |> purrr::set_names(names(emi))
    }
  ) |> purrr::set_names(names(tables_sim$emissions))

  # Final imports

  final_import <- final_demand_domestic * T_matrix_final

  ## Multipliers

  # Output

  output_multipliers <- L_matrix[sectors, sectors] %*% diag(rep(1, nrow(L_matrix[sectors, sectors])))

  colnames(output_multipliers) <- colnames(L_matrix[sectors, sectors])

  # Employment

  employment_multipliers <- diag(employed_over_output) %*% L_matrix[sectors, sectors]

  rownames(employment_multipliers) <- rownames(L_matrix[sectors, sectors])

  # Value added

  va_multipliers <- diag(va_ratio) %*% L_matrix[sectors, sectors]

  rownames(va_multipliers) <- rownames(L_matrix[sectors, sectors])

  # emissions

  emissions_multipliers <- purrr::map(
    names(tables_sim$emissions),
    \(x){

      emi <- tables_sim$emissions[[x]]

      purrr::map(
        names(emi),
        \(y) {

          ratio <- emi[[y]] / tables_sim$va["P1", ]

          multi <- diag(ratio) %*% L_matrix[sectors, sectors]

          multi
        }
      ) |> purrr::set_names(names(emi))
      }
    )|> purrr::set_names(names(tables_sim$emissions))

  ### Recap table



  sum_emissions <- purrr::map(
    names(emissions),
    \(x){

      out <- emissions[[x]]

      purrr::map_vec(
        names(out),
        \(y){

          sum(out[[y]])

        }
      ) |> purrr::set_names(names(out))
    }
  ) |> purrr::set_names(names(emissions))

  recap <- c(
    gdp = sum(va) + sum(indirect_taxes),
    indirect_taxes = sum(indirect_taxes),
    intermediate_imports = sum(intermediate_imports),
    final_imports = sum(final_import),
    output = sum(rowSums(output)[sectors]),
    employed = sum(employment),
    emissions = sum_emissions
  )


  results <- list(
    output = output,
    value_added = va,
    intermediate_imports = intermediate_imports,
    indirect_taxes = indirect_taxes,
    employment_persons = employment,
    emissions = emissions,
    recap = recap,
    multipliers = list(
      output = output_multipliers,
      employment = employment_multipliers,
      va = va_multipliers,
      emissions = emissions_multipliers
    )
  )



  results


}
